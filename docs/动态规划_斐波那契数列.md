# Python 算法及数据结构
记不得过去的人，注定要重蹈覆辙
# 斐波那契数列
```python
def fib(n):
    if n < 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
   
def fib_dy(n):
    if n < 0:
        return 0
    dp = [-1] * (n + 1)
    print(dp)
    dp[1] = dp[2] = 1
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    print(dp)
    return dp[n]
    
start = time.time()
print(fib_dy(1000))
end = time.time()
print(end - start)
```
斐波那契数列理解起来非常简单，如果不是亲自实验，我从未想过简单的改变能对性能有巨大的提升。

fib 函数是根据定义写出来的，我们通常都是使用递归的方式去实现，当然代码不一定这么写，但是思想基本都是递归的思想。试着想一下，用递归思想，当我要计算 fib(1000) 的时候，我要先计算 999 和998，而计算 999 需要先计算998和997，那么仅仅这里就不难看到计算 1000 需要计算 998，计算 999 也需要计算 998，也就是计算了两次，依此类推，递归计算量是很大的。

fib_dy 函数是根据动态规划来计算的，先建立一个 n+1 的数组，每一次的数据都保存下来了，不需要重复的计算。

fib_dy(1000) 所花费的时间也不过 0.0059s

fib(1000) 则直接无法计算，递归的嵌套太深了，我们当然可以通过优化代码来使其生效，但是计算 fib(20) 所花费的时间就已经达到了 0.0029s，计算 fib(30) 达到了 0.337s

